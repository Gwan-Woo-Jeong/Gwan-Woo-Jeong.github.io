---
layout: single
title: "[Web] 이벤트 플로우 (버블링, 캡처링)"
categories: web-network
tag: [Web, Browser, Event Flow, Event Capturing, Event Bubbling]
toc: true
toc_sticky: true
excerpt: '
이벤트란?

이벤트란 클릭이나 키보드 입력과 같이 일반적으로 사용자가 행하는 모든 동작을 일컫는다.

사용자의 입력을 받기 위해, 우린 HTML 요소에 이벤트를 연결해주는데 이것을 이벤트 바인딩이라고 하고 이벤트를 우리의 의도대로 처리하는 행위를 **이벤트 핸들링**이라고 한다.
'
header:
  teaser:
---

![]()

<br />
# 이벤트란?

**이벤트**란 클릭이나 키보드 입력과 같이 일반적으로 사용자가 행하는 모든 동작을 일컫는다.

사용자의 입력을 받기 위해, 우린 HTML 요소에 이벤트를 연결해주는데 이것을 **이벤트 바인딩**이라고 하고 이벤트를 우리의 의도대로 처리하는 행위를 **이벤트 핸들링**이라고 한다.

# 이벤트 플로우

이벤트 핸들링을 위해 우린 브라우저 내에서 이벤트가 어떻게 동작하는 지 알 필요가 있다.

HTML 요소들은 태그 안에 태그가 위치하는 식으로 계층적으로 이루어져있다. 때문에 한 요소에 이벤트가 발생할 경우, 해당 요소의 부모 이벤트들이 전부 실행되는 **연쇄적 이벤트 흐름(이벤트 플로우)**이 일어난다.

예를 들어, div - body - html가 중첩된 구조의 웹 사이트가 있다고 하자. 우리가 div를 클릭할 시, div에 등록된 클릭 이벤트가 실행된다.

그런데 만약 부모 요소인 body와 html에 바인딩된 클릭 이벤트가 있다면, 이벤트 플로우에 의해 해당 클릭 이벤트도 실행되게 된다.

![]()

사용자가 직접적으로 발생시킨 이벤트가 바인딩된 요소는 이벤트의 시발점이 되고, 이로 인해 중첩된 요소들은 이벤트 탑승을 하게 된다.

# target / currentTarget

이벤트 핸들러(함수)를 이벤트에 바인딩하면 해당 함수의 인자로 이벤트에 대한 다양한 정보가 포함된 이벤트 객체 주어진다.

우리는 이벤트 객체의 `target` 과 `currentTarget` 이라는 프로퍼티를 통해 이벤트가 정확히 어디서 발생했는지 에 관한 정보를 알 수 있다.

이 둘의 차이를 다음 예시 코드를 통해 알아보자.

```jsx
const body = document.body;
body.addEventListener("click", (e) => {
  e.target; // ?
  e.currentTarget; // ?
  this; // ?
});
```

## target

이벤트의 시발점이 되는 요소다. 즉, 이벤트 핸들러를 실행시킨 요소라고 할 수 있다. 위 예시에서, body의 이벤트 핸들러는 div의 클릭으로 인해서 실행되었다. 따라서, `[e.target](http://e.target)` 은 div이다.

## currentTarget

이벤트 핸들러가 직접적으로 바인딩 된 요소다. 위 예시에서, body의 이벤트 핸들러가 바인딩 된 요소는 당연하게도 body이다. 따라서, `e.currentTarget` 은 body이다.

추가적으로, 이벤트 핸들러 내에서 `this`는 현재 실행 중인 이벤트인 `currentTarget`을 의미한다.

```jsx
body.addEventListener("click", (e) => {
  e.target; // div
  e.currentTarget; // body
  this; // body
});
```

![]()

# 이벤트 전파 단계

HTML 요소의 이벤트는 계층적 구조로 인해 이벤트의 연쇄적인 흐름(이벤트 플로우)이 일어난다고 했다. 이 이벤트의 흐름을 이벤트가 전파(propagate)된다고도 표현한다.

모든 이벤트는 다음 3가지 전파 단계를 가진다.

1. 캡처 단계 (이벤트 캡처링)
2. 타겟 단계
3. 버블 단계 (이벤트 버블링)

다음 그림을 보며, 각 단계를 살펴보자.

![]()

## 캡처 단계 (이벤트 캡처링)

이벤트가 하위 요소로 전파되는 단계다. 즉, 자식 요소에서 일어난 이벤트가 부모 → 자식으로 이어진다. 이 전파 방식을 이벤트 캡처링이라고 한다.

> 이벤트가 이벤트가 일어난 요소을 찾으러 가는 모습 (capture : 포획하다)을 상상해보자.

실제 코드에서 자주 쓰이진 않지만, 가끔 유용하게 쓰이기도 한다.

## 타겟 단계

이벤트가 실제 주인에게 전달되는 단계다. 즉, 이벤트가 실제로 바인딩 된 요소(`currentTarget`)의 이벤트가 실행된다.

그림에서, 실제 클릭의 대상(타겟)인 div에게 클릭 이벤트가 전달되는 단계이다.

## 버블 단계 (이벤트 버블링)

이벤트가 상위 요소로 전파되는 단계다. 즉, 자식 요소에서 일어난 이벤트가 자식 → 부모로 이어진다. 이 전파 방식을 이벤트 버블링이라고 한다.

> 이벤트가 발생한 요소로부터 생긴 거품이 다른 요소로 퍼지는 모습을 상상해보자.

이벤트 **버블링은 브라우저 이벤트의 기본 전파 방식**이다. 그러므로, 그림에서 아무런 이벤트 제어를 하지 않는다면 3 → 4 → 5 순으로 이벤트가 실행된다.

## 왜 전파될까?

브라우저는 왜 우리가 원하지도 않는 이벤트를 발생시켜 일을 복잡하게 만드는걸까? 이에 대해 다음과 같은 이유를 들 수 있다.

1 ) 자식과 부모 요소가 겹쳐있기 때문에, 엄밀히 보면 자식 요소를 클릭하면 동시에 부모 요소를 클릭한 것과 같다.

2 ) 이런 특징 덕분에, 이벤트 바인딩을 시키는 코드의 양을 줄일 수 있다.
예를 들어, ul 요소 안에 여러 li 요소가 여러 개 있다면 모든 li 요소에 이벤트를 걸어주는 것은 매우 번거로운 일이다.

```html
<ul id="post-list">
  <li id="post-1">Item 1</li>
  <li id="post-2">Item 2</li>
  <li id="post-3">Item 3</li>
  <li id="post-4">Item 4</li>
  <li id="post-5">Item 5</li>
  <li id="post-6">Item 6</li>
</ul>
```

이 때, 부모 요소인 ul 요소에 이벤트를 등록하면, 그 안의 모든 li 요소에 이 이벤트가 전파되어 코드의 양을 대폭 줄일 수 있다. 이 기법을 **이벤트 위임**이라한다.

# 이벤트 제어 방법

보통의 경우, 우리가 직접 클릭한 요소의 이벤트만 발생시키고 싶지 그

currentTarget과 target이 일치하지 않는 경우

![]()

어떤 단계에서 실행될 것인지 선택지가 주어진다. (캡처 vs 버블 : 기본값 버블)

진짜 주인은 div인데, 가장 반대쪽의 HTML부터 실행되는건 말이 안됨.

![]()

body - 버블 / html - 캡처

## 이벤트 중단 (event.stopPropagation)

![]()

# Reference

- [https://youtu.be/7gKtNC3b_S8](https://youtu.be/7gKtNC3b_S8)
- [https://ko.javascript.info/bubbling-and-capturing](https://ko.javascript.info/bubbling-and-capturing)
- [https://inpa.tistory.com/entry/JS-📚-버블링-캡쳐링](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81)
