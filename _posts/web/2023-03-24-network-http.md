---
layout: single
title: '[Network] HTTP란?'
categories: web-network
tag: [Web, Netwrok, HTTP]
toc: true
toc_sticky: true
excerpt: '
HTTP란?

HTTP는 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)의 약어로, 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다. 웹 페이지를 방문할 때마다 사용자의 컴퓨터는 HTTP를 통해 인터넷 어딘가에 있는 다른 컴퓨터에서 해당 페이지를 다운로드한다.

프로토콜은 상호 간에 정의한 규칙을 의미하며, 특정 기기 간에 데이터를 주고받기 위해 정의된다. 통신 프로토콜은 각각의 기기가 데이터를 주고받을 때의 규칙을 명시하여, 데이터 전송 과정을 원활하게 만든다.

컴퓨터 네트워크에서 데이터를 보내고 받는 성격에 따라, 다양한 프로토콜이 만들어졌다. 예를 들어, 웹 문서를 주고받을 때는 HTTP를 사용하고, 파일을 주고받을 때는 FTP를, 메일은 SMTP, POP 등의 프로토콜을 사용한다.

웹에서는 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용하고 있다. HTTP 프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며, 기본 포트는 80번이다.
   >
'
header:
  teaser:  ../../images/2023-02-27-browser-rendering/how-browser-rendering-works.png

---

![how-browser-rendering-works.png](../../images/2023-02-27-browser-rendering/how-browser-rendering-works.png)

<br />

# HTTP란?

HTTP는 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)의 약어로, 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다. 웹 페이지를 방문할 때마다 사용자의 컴퓨터는 HTTP를 통해 인터넷 어딘가에 있는 다른 컴퓨터에서 해당 페이지를 다운로드한다.

프로토콜은 상호 간에 정의한 규칙을 의미하며, 특정 기기 간에 데이터를 주고받기 위해 정의된다. 통신 프로토콜은 각각의 기기가 데이터를 주고받을 때의 규칙을 명시하여, 데이터 전송 과정을 원활하게 만든다.

컴퓨터 네트워크에서 데이터를 보내고 받는 성격에 따라, 다양한 프로토콜이 만들어졌다. 예를 들어, 웹 문서를 주고받을 때는 HTTP를 사용하고, 파일을 주고받을 때는 FTP를, 메일은 SMTP, POP 등의 프로토콜을 사용한다.

웹에서는 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용하고 있다. HTTP 프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며, 기본 포트는 80번이다.

<br />

# 무상태성 (stateless)

HTTP 프로토콜의 특징 중 하나는 무상태(stateless)성이다. 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리된다는 의미다. 쉽게 말하면, 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 것이다.

이러한 특징 덕분에 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, **다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점**이 있다.

하지만 **클라이언트가 서버에 추가 데이터를 전송해야 한다는 단점**도 있다.

상태 유지와 무상태성에 대해 좀 더 면밀히 파해쳐보자.

## 상태 유지

클라이언트 - 서버 관계에서, 서버가 클라이언트의 이전 상태를 저장하고 다음 요청에 대해 이전 상태를 유지하는 것을 의미한다. 예를 들어, 한 번 홈페이지에 로그인하면 페이지를 이동하더라도 로그인이 계속 유지되는 것은 서버가 클라이언트의 상태를 계속 유지하고 있기 때문이다. 이러한 상태 유지는 보통 쿠키(Cookie)와 세션(Session) 메모리를 이용하여 구현된다.

상태 유지의 문제점은, 해당 서버가 멈추거나 사용할 수 없을 때 발생한다. 새로운 서버에서는 이전 서버에서 가지고 있던 상태값들을 가지고 있지 않기 때문이다.

예를 들어, 로그인한 유저가 게시판 페이지에 들어가서 글쓰기 버튼을 눌렀는데, 다시 로그인 하라는 화면이 뜰 수 있다. 이 유저의 로그인 정보가 있는 서버가 다운되어 다른 서버가 대신 역할을 이어 받았는데, 해당 유저의 로그인 정보가 없기 때문에 발생하는 문제다.

또한 상태 유지 방식은 하나의 서버가 만약 100명의 클라이언트를 처리할 수 있을 때, 100명보다 많은 클라이언트가 몰리면 이미 연결된 100명의 클라이언트 중 일부가 빠져나가야 다음 클라이언트가 처리할 수 있다. 이는 클라이언트의 상태를 저장하기 위한 용량 한계가 존재하기 때문이다.

따라서, 현업에서는 클라이언트의 상태 데이터를 따로 캐시 서버(Redis)에 저장하여 이용하는 경우가 많다.

## 무상태

클라이언트 - 서버 관계에서, 서버가 클라이언트의 상태 정보를 보존하지 않는다. 대신 클라이언트에서 요청할 때마다 필요한 정보를 모두 담아서 서버로 보내고, 서버는 해당 요청을 처리한 뒤 응답을 보내는 방식이다.

서버는 상태 정보를 보존하지 않아도 되므로, **상태 유지에 대한 부담이 매우 적다**. 또한 서버간에 요청을 분산시키기 쉽기 때문에 대규모 트래픽 발생 시에도 **서버 확장이 용이**하다.

하지만 이러한 구조에서는 클라이언트가 모든 상태 정보를 가지고 있어야 하므로, **클라이언트의 부담이 증**가할 수 있다. 또한 모든 요청에 필요한 정보를 모두 담아서 보내야 하므로 **네트워크 부하가 증가**할 수 있다.

<br />

# 비연결성 (connetionless)

HTTP 프로토콜의 또 다른 특징 중 하나는 비연결성(stateless)성이다. 비연결성은 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 성질을 말한다.

## 장점

HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되었다. 만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생하게 된다. 이를 줄이면 더 많은 클라이언트와 연결을 할 수 있으므로, HTTP는 한 번의 통신 후 서버 - 클라이언트의 연결을 끊는다.

## 단점

서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해, 매번 새로운 연결을 시도/해제의 과정을 거쳐야하므로 연결/해제에 대한 오버헤드가 발생한다.

### KeepAlive

이에 대한 해결책으로 HTTP의 KeepAlive 속성을 사용할 수 있다.

KeepAlive는 지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우, 상대방의 안부를 묻기위해 패킷을 주기적으로 보내는것을 의미한다. 이 때 패킷에 반응이 없으면 접속을 끊게된다.

주기적으로 클라이언트의 상태를 체크한다는 것으로 미루어보아 KeepAlive 역시 완벽한 해결책은 아니다.

설령 KeepAlive 속성이 On 상태라해도, 서버가 바쁜 환경에서는 프로세스 수가 기하급수적으로 늘어나기 때문에 KeepAlive로 상태를 유지하기 위한 메모리를 많이 사용하게 되므로 주의해야한다.
