---
layout: single
title: '[Web] 브라우저의 렌더링 과정'
categories: web-etc
tag: [Browser, HTML, CSS, Javascript]
toc: true
toc_sticky: true
excerpt: '
이번 포스팅에서는 우리가 브라우저를 켰을 때, 화면에 웹 페이지가 그려지기 까지 과정을 살펴보고자 한다. 본문으로 들어가기 전에, 결론부터 간략히 요약하자면 브라우저는 다음과 같은 과정을 통해 웹 페이지를 보여준다.

1 . 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 필요한 **리소스를 요청**하고 서버로부터 **응답**을 받는다.

2 . 브라우저의 렌더링 엔진은 **HTML, CSS를 파싱**하여 **DOM과 CSSOM을 생성**한 후 이 둘을 **렌더 트리로 결합**한다.

3. 그리고 **자바스크립트를 파싱**하여 **AST를 생성**하고 **바이트코드로 변환하여 실행**한다. 이 때, 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있는데 변경 사항이 있다면 다시 렌더 트리를 결합한다.

4. 렌더 트리를 기반으로 HTML 요소의 **레이아웃을 계산**한다.

5. 브라우저 화면에 HTML 요소를 **페인팅**한다.
   >
'
header:
  teaser: 

---

이번 포스팅에서는 우리가 브라우저를 켰을 때, 화면에 웹 페이지가 그려지기 까지 과정을 살펴보고자 한다. 본문으로 들어가기 전에, 결론부터 간략히 요약하자면 브라우저는 다음과 같은 과정을 통해 웹 페이지를 보여준다.

1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 필요한 **리소스를 요청**하고 서버로부터 **응답**을 받는다.

2. 브라우저의 렌더링 엔진은 **HTML, CSS를 파싱**하여 **DOM과 CSSOM을 생성**한 후 이 둘을 **렌더 트리로 결합**한다.

3. 그리고 **자바스크립트를 파싱**하여 **AST를 생성**하고 **바이트코드로 변환하여 실행**한다. 이 때, 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있는데 변경 사항이 있다면 다시 렌더 트리를 결합한다.

4. 렌더 트리를 기반으로 HTML 요소의 **레이아웃을 계산**한다.

5. 브라우저 화면에 HTML 요소를 **페인팅**한다.

이 내용을 이해하기 위해선, **파싱**과 **렌더링**이라는 브라우저의 기능을 알아야 한다.

> 파싱 (parsing) : 프로그래밍 언어의 문법 맞게 작성된 텍스트 문서를 읽고 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 담아 파스 트리 (parse tree)라는 자료구조를 기반으로 프로그래밍 언어와 기계어의 중간 언어인 바이트코드를 실행한다.

> 렌더링 : HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저 화면에 보이게 하는 작업을 의미한다.

## 요청 & 응답

먼저 브라우저 렌더링에 필요한 리소스(HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터)를 서버로부터 가져오기 위해 서버에 요청한다. 브라우저에는 서버에 요청을 전송하기 위해 주소창이 있다. 주소창에 URL을 입력한 후 엔터를 누르면, URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 이 주소를 가지고 있는 서버에게 요청을 보내게 된다.

![url-structure-and-scheme.png](../../images/2023-02-27-browser-rendering/url-structure-and-scheme.png)

예를 들어, `https://google.com`을 주소창에 입력한 후 엔터를 누르면, 루트 요청이 google.com 서버로 전송된다.

> **루트 요청** : scheme과 host로만 구성된 URI에 의한 요청

루트 요청에는 구체적으로 어떤 리소스를 요구하는지 명시되어 있지 않지만 서버는 루트 요청에 대해 암묵적으로 index.html을 응답하도록 설정되어있다. 이 말은 즉, `https://google.com`은 `https://google.com/index.html`과 같은 요청이다.

만약, index.html이 아닌 다른 정적 파일을 요청하기 위해선 `https://google.com/assets/data/data.json` 같이 요청할 파일의 정적 경로와 파일명을 host 뒤의 path에 명시하여 서버에 요청하면 된다. 서버는 이에 대한 응답으로 assets/data 폴더 안의 data.json 파일을 전송할 것이다.

실제로 이 과정을 브라우저 내에서 확인해보자. 요청과 응답은 개발자 도구의 network 탭에서 확인할 수 있다.

![browser-rendering-network-tab.png](../../images/2023-02-27-browser-rendering/browser-rendering-network-tab.png)

위 화면은 처음 구글에 접속했을 때, 개발자 도구에서 network 탭의 모습이다. 그런데, 분명 `https://google.com/(index.html)`로 요청했지만 index.html과 함께 요청하지 않은 이미지와 json 등 다른 리소스까지 같이 응답을 받았다.

그 이유는 브라우저가 index.html 문서 안에 있는 요청들에 대한 응답까지 받아오기 때문이다. 구체적으로, 브라우저 렌더링 엔진이 HTML 파일을 파싱할 때, 첫 라인부터 마지막까지 차례대로 파싱한다. 이 과정 중에, 외부 리소스를 가져오는 태그가 있다면, 브라우저는 리소스 파일을 서버로 요청한다. 예를 들어, CSS 파일을 요청하는 태그로는 `<link>`, 자바스크립트 파일 요청 태그는 `<script>`, 이미지 파일 요청 태그로 `<img>` 가 있다.

## HTML 파싱 / DOM 생성

서버에서 받아온 HTML 문서는 오직 텍스트로만 이루어져있다. 이 텍스트를 우리가 아는 웹페이지로 변환하기 위해서 문서를 브라우저가 이해할 수 있는 자료구조의 형태로 바꿔주어야 한다. 이 객체 형태의 자료구조를 **DOM 구조라고 한다**.

아래 그림은 브라우저 렌더링 엔진이 HTML 파싱부터 DOM을 생성하는 과정을 보여준다. 이 순서들을 더 자세히 알아보자.

![dom-process.png](../../images/2023-02-27-browser-rendering/dom-process.png)

**1. 바이트(Bytes)** : 서버가 브라우저 요청에 대해 바이트 (2진수) 형태로 된 HTML 문서를 응답한다.

**2. 문자열(Characters)** : HTML 문서는 meta 태그의 charset 속성에 지정된 인코딩 방식에 따라 문자열로 변환된다. 서버는 이 인코딩 방식을 응답 헤더에 담아 브라우저에게 전달한다.

**3. 토큰(Tokens)** : 문자열로 이루어진 HTML문서를 토큰들로 분해한다.

> 토큰 : 문법적 의미를 갖는 코드의 최소 단위

**4. 노드(Nodes)** : 각 토큰을 객체로 변환하여 노드를 생성한다.

> 노드 : DOM을 구성하는 기본 요소

**5. DOM** : HTML 요소들의 중첩관계를 바탕으로 노드들을 트리 자료구조로 구성한다. 이 트리 자료구조를 DOM이라고 한다.
